# Index


### 인덱스란?

- 인덱스란 추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조
- 테이블의 모든 데이터를 검색하면 시간이 오래 걸리기 때문에 데이터와 데이터의 위치를 포함한 자료구조를 생성하여 빠르게 조회할 수 있도록 돕는다.

<br>

### 인덱스의 관리

- DBMS는 index를 항상 최신의 정렬된 상태로 유지해야 한다.
- INSERT : 새로운 데이터에 대한 인덱스를 추가
- DELETE : 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업을 진행
- UPDATE : 기존의 인덱스를 사용하지 않음 처리 후 갱신된 데이터에 대해 인덱스를 추가

<br>

### 인덱스의 장점과 단점

- 장점
    - 테이블을 조회하는 속도와 그에 따른 성능 향상
    - 전반적인 시스템의 부하를 줄임
- 단점
    - 인덱스를 관리하기 위해 추가 작업이 필요
    - 인덱스를 잘못 사용할 경우 오히려 성능이 저하되는 역효과 발생
    
    (CREATE, DELETE, UPDATE가 빈번한 속성에 인덱스를 걸게 되면 인덱스의 크기가 커져서 성능이 오히려 저하되는 역효과 발생)
    
<br>

### 인덱스를 사용하면 좋은 경우

- 규모가 작지 않은 테이블
- INSERT, UPDATE, DELETE가 자주 발생하지 않는 컬럼
- JOIN이나 WHERE 또는 ORDER BY에 자주 사용되는 컬럼
- 데이터의 중복도가 낮은 컬럼

<br>

### 인덱스의 자료구조

- 해시 테이블
    - key와 value로 데이터를 저장하는 자료구조
    - 빠른 데이터 검색에 유용
    - 단일 탐색에 O(1)의 시간복잡도를 가진다.
    - 단점
        - 해시 테이블은 내부적으로 데이터 정렬이 되어있지 않으므로 등호 연산에 적합하다.
        - 부등호 연산이 자주 사용되는 데이터 베이스 검색에는 효율적이지 않다.
- B Tree
    - B Tree에 저장된 데이터들은 항상 정렬된 상태로 유지된다.
    - 부등호 연산에 대한 효율적인 데이터 탐색이 가능하다.
    - 탐색, 저장, 수정, 삭제에 모두 O(logN)의 시간복잡도를 가진다.
- B+Tree
    - B Tree를 개선시킨 자료구조
    - 리프노드만 인덱스와 함께 데이터를 가지고 있고 나머지 노드들은 인덱스만 갖는다.
    - 리프노드들은 LInkedList로 연결되어있다.
    - 하나의 노드에 더 많은 key들을 담을 수 있어서 트리의 높이가 낮아진다.
    - fullScan시 B tree는 모든 노드를 확인해야 하지만 B+ tree는 리프노드를 저장한 리스트에 대해 한번의 선형 탐색만 수행하면 된다.

<br>

### 인덱스의 종류

- 키에 따른 인덱스
    - 기본 인덱스(Primary Index) : 기본키를 포함하는 인덱스(키의 순서가 레코드의 순서를 결정)
    - 보조 인덱스(Secondary Index) : 기본 인덱스 이외의 인덱스 (키의 순서와 레코드 순서가 상관 없음)
    
- 파일 조직에 따른 인덱스
    - 클러스터 인덱스(Clusteded Index)
        - 데이터 레코드의 물리적 순서가 그 파일에 대한 인덱스 엔트리 순서와 유사하게 유지되도록 구성된 인덱스
        - 테이블 당 한 개만 생성 가능
    - 넌클러스터 인덱스 (nonclustered Index)

- 데이터 범위에 따른 인덱스
    - 밀집 인덱스(Dense Index)
    - 희소 인덱스(Sparse Index)
